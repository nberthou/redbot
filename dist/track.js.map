{"version":3,"file":"track.js","sourceRoot":"","sources":["../src/track.ts"],"names":[],"mappings":";;;AAAA,yCAAoC;AACpC,4CAAkF;AAClF,qDAA8C;AAU9C,MAAM,IAAI,GAAG,GAAG,EAAE,GAAG,CAAC,CAAC;AAEvB,MAAa,KAAK;IAOd,YAAoB,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAa;QACrE,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IAC3B,CAAC;IAEM,mBAAmB;QACtB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACnC,MAAM,OAAO,GAAG,qBAAI,CAChB,IAAI,CAAC,GAAG,EACR;gBACI,CAAC,EAAE,GAAG;gBACN,CAAC,EAAE,EAAE;gBACL,CAAC,EAAE,qDAAqD;gBACxD,CAAC,EAAE,MAAM;aACZ,EACD,EAAE,KAAK,EAAE,CAAC,QAAQ,EAAE,MAAM,EAAE,QAAQ,CAAC,EAAE,CAC1C,CAAC;YACF,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;gBACjB,MAAM,CAAC,IAAI,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC;gBAC/B,OAAO;aACV;YACD,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;YAC9B,MAAM,OAAO,GAAG,CAAC,KAAY,EAAE,EAAE;gBAC7B,IAAI,CAAC,OAAO,CAAC,MAAM;oBAAE,OAAO,CAAC,IAAI,EAAE,CAAC;gBACpC,MAAM,CAAC,MAAM,EAAE,CAAC;gBAChB,MAAM,CAAC,KAAK,CAAC,CAAC;YAClB,CAAC,CAAC;YACF,OAAO;iBACF,IAAI,CAAC,OAAO,EAAE,GAAG,EAAE;gBAChB,kBAAU,CAAC,MAAM,CAAC;qBACb,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,OAAO,CAAC,2BAAmB,CAAC,KAAK,CAAC,MAAM,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAA;YAC/G,CAAC,CAAC;iBACD,KAAK,CAAC,OAAO,CAAC,CAAC;QACxB,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAW,EAAE,OAAwD;QAC1F,MAAM,IAAI,GAAG,MAAM,mBAAO,CAAC,GAAG,CAAC,CAAC;QAChC,MAAM,cAAc,GAAG;YACnB,OAAO;gBACH,cAAc,CAAC,OAAO,GAAG,IAAI,CAAC;gBAC9B,OAAO,CAAC,OAAO,EAAE,CAAC;YACtB,CAAC;YACD,QAAQ;gBACJ,cAAc,CAAC,QAAQ,GAAG,IAAI,CAAC;gBAC/B,OAAO,CAAC,QAAQ,EAAE,CAAC;YACvB,CAAC;YACD,OAAO,CAAC,KAAY;gBAChB,cAAc,CAAC,OAAO,GAAG,IAAI,CAAC;gBAC9B,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC3B,CAAC;SACJ,CAAC;QACF,OAAO,IAAI,KAAK,CAAC;YACb,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,KAAK;YAC9B,GAAG;YACH,GAAG,cAAc;SACpB,CAAC,CAAC;IACP,CAAC;CACJ;AA3ED,sBA2EC","sourcesContent":["import { getInfo } from 'ytdl-core';\r\nimport { AudioResource, createAudioResource, demuxProbe } from '@discordjs/voice';\r\nimport { raw as ytdl } from 'youtube-dl-exec';\r\n\r\nexport interface TrackData {\r\n    url: string;\r\n    title: string;\r\n    onStart: () => void;\r\n    onFinish: () => void;\r\n    onError: (error: Error) => void;\r\n}\r\n\r\nconst noop = () => { };\r\n\r\nexport class Track implements TrackData {\r\n    public readonly url: string;\r\n    public readonly title: string;\r\n    public readonly onStart: () => void;\r\n    public readonly onFinish: () => void;\r\n    public readonly onError: (error: Error) => void;\r\n\r\n    private constructor({ url, title, onStart, onFinish, onError }: TrackData) {\r\n        this.url = url;\r\n        this.title = title;\r\n        this.onStart = onStart;\r\n        this.onFinish = onFinish;\r\n        this.onError = onError;\r\n    }\r\n\r\n    public createAudioResource(): Promise<AudioResource<Track>> {\r\n        return new Promise((resolve, reject) => {\r\n            const process = ytdl(\r\n                this.url,\r\n                {\r\n                    o: '-',\r\n                    q: '',\r\n                    f: 'bestaudio[ext=webm+acodec=opus+asr=48000]/bestaudio',\r\n                    r: '100K',\r\n                },\r\n                { stdio: ['ignore', 'pipe', 'ignore'] },\r\n            );\r\n            if (!process.stdout) {\r\n                reject(new Error('No stdout'));\r\n                return;\r\n            }\r\n            const stream = process.stdout;\r\n            const onError = (error: Error) => {\r\n                if (!process.killed) process.kill();\r\n                stream.resume();\r\n                reject(error);\r\n            };\r\n            process\r\n                .once('spawn', () => {\r\n                    demuxProbe(stream)\r\n                        .then((probe) => resolve(createAudioResource(probe.stream, { metadata: this, inputType: probe.type })))\r\n                })\r\n                .catch(onError);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Creates a Track from a video URL and lifecycle callback methods.\r\n     *\r\n     * @param url The URL of the video\r\n     * @param methods Lifecycle callbacks\r\n     * @returns The created Track\r\n     */\r\n    public static async from(url: string, methods: Pick<Track, 'onStart' | 'onFinish' | 'onError'>): Promise<Track> {\r\n        const info = await getInfo(url);\r\n        const wrappedMethods = {\r\n            onStart() {\r\n                wrappedMethods.onStart = noop;\r\n                methods.onStart();\r\n            },\r\n            onFinish() {\r\n                wrappedMethods.onFinish = noop;\r\n                methods.onFinish();\r\n            },\r\n            onError(error: Error) {\r\n                wrappedMethods.onError = noop;\r\n                methods.onError(error);\r\n            },\r\n        };\r\n        return new Track({\r\n            title: info.videoDetails.title,\r\n            url,\r\n            ...wrappedMethods\r\n        });\r\n    }\r\n}"]}